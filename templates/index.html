<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>AI.Stocking</title>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body, input, button, select, label {
            font-family: 'Lato', Arial, sans-serif;
        }
        body { margin: 40px; }
        #chart-container { width: 90vw; max-width: 1200px; margin: auto; }

        /* 自定义 Tooltip 样式，使其看起来像 Chart.js 默认样式 */
        /* ** 核心：极高 Z-INDEX，且在 BODY 根部渲染，解决遮挡问题 ** */
        #chartjs-tooltip {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            color: #fff;
            padding: 8px 12px;
            font-size: 12px;
            line-height: 1.4;
            transition: all 0.1s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 2147483647; 
            pointer-events: none; 
            position: absolute; 
            opacity: 0; 
            /* 确保 Tooltip 的最大宽度，防止在屏幕边缘过宽 */
            max-width: 400px; 
            white-space: normal; /* 允许换行 */
        }
        #chartjs-tooltip div.tooltip-title {
            font-weight: bold;
            padding-bottom: 4px;
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        #chartjs-tooltip div.tooltip-body {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        /* 确保 Tooltip 内部的行也使用 Lato 字体 */
        #chartjs-tooltip * {
            font-family: 'Lato', Arial, sans-serif !important;
        }
    </style>
</head>
<body>
    <div id="chartjs-tooltip"></div>

    <div id="chart-container">
        <canvas id="lineChart"></canvas>
    </div>
    <!-- 底部横向区域：左侧自定义股票，右侧比较日期 -->
    <div id="customStockArea" style="margin:32px auto 0 auto;max-width:1200px;background:rgba(255,255,255,0.92);padding:12px 18px 14px 18px;border-radius:8px;box-shadow:0 1px 8px rgba(0,0,0,0.06);font-family:'Lato',Arial,sans-serif;font-size:13px;">
        <div style="display:flex;align-items:flex-end;justify-content:space-between;flex-wrap:wrap;gap:12px 16px;">
            <div style="flex:1 1 0;min-width:320px;">
                <div style="margin-bottom:2px;font-weight:bold;">自定义股票(最多5个):</div>
                <div style="display:flex;align-items:center;flex-wrap:wrap;gap:12px 16px;">
                    <div id="customStockList" style="display:flex;align-items:center;flex-wrap:wrap;gap:8px 8px;"></div>
                    <div style="display:flex;align-items:center;gap:6px;">
                        <input id="customStockInput" type="text" maxlength="12" placeholder="sh600000" style="width:90px;font-size:13px;">
                        <button id="addCustomStockBtn" style="font-size:13px;">添加</button>
                    </div>
                </div>
            </div>
            <div id="baseDateDiv" style="display:flex;align-items:center;gap:8px;font-size:13px;min-width:220px;">
                <label style="font-family:'Lato',Arial,sans-serif;font-size:13px;">比较日期: <input type="date" id="baseDateInput" value="2025-10-27" style="font-family:'Lato',Arial,sans-serif;font-size:13px;"> </label>
                <button id="baseDateBtn" style="font-family:'Lato',Arial,sans-serif;font-size:13px;">应用</button>
            </div>
        </div>
    </div>
    <div id="chart-container">
        <canvas id="lineChart"></canvas>
    </div>
    <script src="/static/custom_code_loader.js"></script>
    <script src="/static/custom_code_save.js"></script>
    <script>
    // 定义增大后的点半径
    const VISIBLE_POINT_RADIUS = 6;
    const HOVER_POINT_RADIUS = 12;
    let customStocks = []; 

    if (window.Chart && window.ChartAnnotation) {
        Chart.register(window.ChartAnnotation);
    }

    /**
     * 通用的 borderDash 函数
     */
    function getDynamicBorderDash(ctx) {
        const baseIdx = window._chartBaseIdx;
        if (typeof baseIdx !== 'number' || baseIdx < 0) return [];
        if (ctx.p1DataIndex < baseIdx) {
            return [6, 6]; 
        }
        return [];
    }
    const DYNAMIC_DASH_SEGMENT = { borderDash: getDynamicBorderDash };

    async function fetchData(baseDateStr, codes) {
        let url = '/api/lines';
        let params = [];
        if (baseDateStr) params.push('base_date=' + encodeURIComponent(baseDateStr));
        if (codes && codes.length) params.push('codes=' + encodeURIComponent(codes.join(',')));
        if (params.length) url += '?' + params.join('&');
        const resp = await fetch(url);
        return await resp.json();
    }

    /**
     * 根据 priceX 数据计算每个点的半径。
     */
    function getCommentRadii(prices, code) {
        if (!prices || prices.length === 0) return [];
        return prices.map((p) => {
            if (!p || typeof p !== 'object') return 0;
            if (p.comment && p.comment.trim() !== '') return VISIBLE_POINT_RADIUS;
            if (Array.isArray(p.trade_info) && p.trade_info.length > 0) return VISIBLE_POINT_RADIUS;
            if (p.holdings_detail && typeof p.holdings_detail === 'object' && Object.keys(p.holdings_detail).length > 0) return VISIBLE_POINT_RADIUS;
            if (code === 'Deepseek') {
                const hasAnalysis = p.portfolio_analysis && Object.keys(p.portfolio_analysis).length > 0;
                const hasOperations = Array.isArray(p.stock_operations) && p.stock_operations.length > 0;
                if (hasAnalysis || hasOperations) return VISIBLE_POINT_RADIUS;
            }
            return 0;
        });
    }

    if (window.Chart && Chart.defaults) {
        Chart.defaults.font.family = 'Lato, Arial, sans-serif';
    }

    function formatLabelTimestr(s) {
        const d = new Date(s);
        if (isNaN(d.getTime())) return s;
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        const mon = months[d.getMonth()];
        const dd = String(d.getDate()).padStart(2, '0');
        const hh = String(d.getHours()).padStart(2, '0');
        const min = String(d.getMinutes()).padStart(2, '0');
        return `${mon} ${dd} ${hh}:${min}`;
    }

    /**
     * 自定义文本换行函数 (适用于中文，按字符数强制换行)
     * @param {string} text - 需要换行的文本
     * @param {number} maxChars - 每行最大字符数，Deepseek默认15，其他30
     * @returns {string[]} - 包含换行符的字符串数组
     */
    function wordWrap(text, maxChars = 15) {
        if (!text || text.length === 0) return [''];
        const lines = [];
        let startIndex = 0;
        while (startIndex < text.length) {
            let endIndex = Math.min(startIndex + maxChars, text.length);
            let line = text.substring(startIndex, endIndex);
            lines.push(line);
            startIndex = endIndex;
        }
        return lines;
    }


    // ==========================================================
    // ** 核心函数：外部 Tooltip 渲染和定位 (包含底部溢出修复) **
    // ==========================================================
    const externalTooltipHandler = (context) => {
        const { chart, tooltip } = context;
        let tooltipEl = document.getElementById('chartjs-tooltip');

        // 隐藏 Tooltip
        if (tooltip.opacity === 0) {
            tooltipEl.style.opacity = 0;
            return;
        }

        // 1. 生成内容 (完全复制和修改原有的 callbacks.label 逻辑)
        let innerHtml = '';
        if (tooltip.dataPoints.length) {
            
            // --- 检查和过滤逻辑 ---
            const titleContext = tooltip.dataPoints;
            const ds = titleContext[0].dataset;
            const idx = titleContext[0].dataIndex;
            const radii = ds.pointRadius || [];
            
            // 只有标记点（半径 > 0）时才显示 Tooltip
            if (Array.isArray(radii) && radii[idx] === 0) {
                tooltipEl.style.opacity = 0;
                return;
            }
            
            // --- Tooltip 标题逻辑 ---
            innerHtml += `<div class="tooltip-title">${titleContext[0].label}</div>`; 

            // --- Tooltip 内容逻辑 ---
            let bodyLines = [];

            tooltip.dataPoints.forEach((context) => {
                const ds = context.dataset;
                const idx = context.dataIndex;
                const label = ds.label || '';
                const val = context.parsed.y;
                const price = ds.customPrices ? ds.customPrices[idx] : undefined;
                const radii = ds.pointRadius || [];
                
                if (Array.isArray(radii) && radii[idx] === 0) return;
                
                let lines = [];
                
                if (label === 'Deepseek' && price && typeof price === 'object') {
                    // Deepseek 复杂逻辑... (保持上一次的完整内容生成逻辑)
                    lines.push(`Deepseek (归一化): ${val.toFixed(2)}`);
                    // 优先 total_value 字段，其次 total
                    let totalValue = price.total_value !== undefined ? price.total_value : price.total;
                    lines.push(`总价值 (RMB): ${totalValue !== undefined ? Number(totalValue).toFixed(2) : 'N/A'}`);
                    lines.push(`现金 (RMB): ${price.cash ? price.cash.toFixed(2) : 'N/A'}`);
                    const stocks = price.stocks || {};
                    for (const code in stocks) {
                        if (stocks.hasOwnProperty(code)) {
                            const stock = stocks[code];
                            lines.push(
                                `  ${code}: 股数 ${stock.shares}, 价格 ${stock.price ? stock.price.toFixed(2) : 'N/A'}, 市值 ${stock.value ? stock.value.toFixed(2) : 'N/A'}`
                            );
                        }
                    }
                    // 展示 trade_info
                    if (Array.isArray(price.trade_info) && price.trade_info.length > 0) {
                        lines.push('【交易记录】');
                        price.trade_info.forEach(trade => {
                            let tradeLine = `${trade.type}`;
                            if (trade.code) tradeLine += ` ${trade.code}`;
                            if (trade.amount !== undefined) tradeLine += ` 数量:${trade.amount}`;
                            if (trade.price !== undefined) tradeLine += ` 价格:${trade.price}`;
                            if (trade.cost !== undefined) tradeLine += ` 成本:${trade.cost}`;
                            if (trade.comment) tradeLine += ` 备注:${trade.comment}`;
                            lines.push(tradeLine);
                        });
                    }
                    // 展示 holdings_detail
                    if (price.holdings_detail && typeof price.holdings_detail === 'object' && Object.keys(price.holdings_detail).length > 0) {
                        lines.push('【持仓明细】');
                        Object.entries(price.holdings_detail).forEach(([code, detail]) => {
                            let holdingLine = `${code}: 股数${detail.shares}`;
                            if (detail.price !== undefined) holdingLine += ` 价格:${detail.price}`;
                            if (detail.value !== undefined) holdingLine += ` 市值:${detail.value}`;
                            lines.push(holdingLine);
                        });
                    }
                    if (price.portfolio_analysis) {
                        const pa = price.portfolio_analysis;
                        lines.push('【组合分析】');
                        if (pa.date) lines.push(`时间: ${pa.date}`);
                        if (pa.market_summary) {
                            lines.push('市场综述:');
                            const wrappedSummary = wordWrap(pa.market_summary, 40).map(line => ' &nbsp; &nbsp; ' + line); 
                            lines.push(...wrappedSummary);
                        }
                        if (pa.risk_level) lines.push(`风险等级: ${pa.risk_level}`);
                        if (pa.overall_operation) lines.push(`操作建议: ${pa.overall_operation}`);
                        if (pa.trading_plan) {
                            lines.push('交易计划:');
                            const wrappedPlan = wordWrap(pa.trading_plan, 40).map(line => ' &nbsp; &nbsp; ' + line);
                            lines.push(...wrappedPlan);
                        }
                        if (pa.portfolio_comment) {
                            lines.push('点评:');
                            const wrappedComment = wordWrap(pa.portfolio_comment, 40).map(line => ' &nbsp; &nbsp; ' + line);
                            lines.push(...wrappedComment);
                        }
                    }
                    if (Array.isArray(price.stock_operations) && price.stock_operations.length > 0) {
                        lines.push('【操作记录】');
                        price.stock_operations.forEach(op => {
                            const amount = op.amount !== undefined ? op.amount : 'N/A';
                            const priceVal = op.price !== undefined ? op.price : 'N/A';
                            const comment = op.comment !== undefined ? op.comment : '';
                            lines.push(`${op.date.substring(5, 16)} ${op.code} ${op.type} 数量:${amount} 价格:${priceVal} 备注:${comment}`);
                        });
                    }
                    if (typeof price.comment === 'string' && price.comment.trim() !== '') {
                        lines.push('备注:');
                        const wrappedGeneralComment = wordWrap(price.comment, 40).map(line => ' &nbsp; &nbsp; ' + line);
                        lines.push(...wrappedGeneralComment);
                    }
                    bodyLines.push(...lines); 
                }
                
                else if (price && typeof price === 'object') {
                    // 市值线节点，显示 trade_info 和 holdings_detail
                    const originalPrice = typeof price === 'object' ? price.value || price.total_value || price.total : price;
                    lines.push(`${label}: ${val.toFixed(2)} (总市值: ${originalPrice !== undefined ? originalPrice.toFixed(2) : 'N/A'})`);
                    // 展示 trade_info
                    if (Array.isArray(price.trade_info) && price.trade_info.length > 0) {
                        lines.push('【交易记录】');
                        price.trade_info.forEach(trade => {
                            let tradeLine = `${trade.type}`;
                            if (trade.code) tradeLine += ` ${trade.code}`;
                            if (trade.amount !== undefined) tradeLine += ` 数量:${trade.amount}`;
                            if (trade.price !== undefined) tradeLine += ` 价格:${trade.price}`;
                            if (trade.cost !== undefined) tradeLine += ` 成本:${trade.cost}`;
                            if (trade.comment) tradeLine += ` 备注:${trade.comment}`;
                            lines.push(tradeLine);
                        });
                    }
                    // 展示 holdings_detail
                    if (price.holdings_detail && typeof price.holdings_detail === 'object' && Object.keys(price.holdings_detail).length > 0) {
                        lines.push('【持仓明细】');
                        Object.entries(price.holdings_detail).forEach(([code, detail]) => {
                            let holdingLine = `${code}: 股数${detail.shares}`;
                            if (detail.price !== undefined) holdingLine += ` 价格:${detail.price}`;
                            if (detail.value !== undefined) holdingLine += ` 市值:${detail.value}`;
                            lines.push(holdingLine);
                        });
                    }
                    // 展示 comment
                    if (price.comment && price.comment.trim() !== '') {
                        const wrappedComment = wordWrap(price.comment, 40).map(line => ' &nbsp; ' + line);
                        lines.push('备注:');
                        lines.push(...wrappedComment);
                    }
                    bodyLines.push(...lines);
                } else if (price !== undefined) {
                    const originalPrice = typeof price === 'object' ? price.value || price.total : price;
                    bodyLines.push(`${label}: ${val.toFixed(2)} (原始价格: ${originalPrice.toFixed(2)})`);
                } else {
                    bodyLines.push(`${label}: ${val.toFixed(2)}`);
                }
            });

            innerHtml += '<div class="tooltip-body">' + bodyLines.map(line => `<div>${line}</div>`).join('') + '</div>';

            // 2. 注入 HTML
            tooltipEl.innerHTML = innerHtml;
            // 必须在设置 opacity=1 之前获取尺寸，否则尺寸可能不准确
            tooltipEl.style.opacity = 1; 
            
            // 3. ** 核心修复：使用 getBoundingClientRect 获取 Canvas 绝对位置 **
            const canvasRect = chart.canvas.getBoundingClientRect();
            
            // Tooltip 的原始定位点（相对于 Canvas 左上角）
            const caretX = tooltip.caretX; 
            const caretY = tooltip.caretY; 

            // Tooltip 元素的尺寸 (渲染后才能获取)
            const tooltipWidth = tooltipEl.offsetWidth;
            const tooltipHeight = tooltipEl.offsetHeight;

            // 初始计算 Tooltip 的绝对位置 (相对于 Viewport)
            let finalX = canvasRect.left + caretX;
            let finalY = canvasRect.top + caretY - tooltipHeight - 10; // ** 默认：定位在点上方 10px 处 **

            // 4. ** 边界检查和修正（防止溢出屏幕） **
            
            const viewportPadding = 10; // 留出 10px 边距
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight; // 视口高度

            // 检查 Y 轴：防止溢出顶部
            if (finalY < viewportPadding) {
                // 如果溢出顶部，则将 Tooltip 定位到点下方
                finalY = canvasRect.top + caretY + 10; // 定位在点下方 10px 处
            }

            // ** 检查 Y 轴：防止溢出底部 (这是新增加的修复) **
            // 检查 Tooltip 的底边是否在屏幕内
            if (finalY + tooltipHeight > viewportHeight - viewportPadding) {
                // 如果溢出底部，强制 Tooltip 贴紧屏幕底部安全边距
                finalY = viewportHeight - tooltipHeight - viewportPadding;
                // 注意：如果 Tooltip 太大，以至于即使贴着底部也溢出顶部，我们宁愿让它溢出顶部
                // (因为前面已经做了顶部检查，但这次是强制调整到底部)
                // 另一种策略是，如果底部溢出，强制放在数据点上方，但因为初始就在上方，所以这次是修正强制贴底
                
                // 确保至少不低于 Canvas 顶部 (如果 Tooltip 巨大，防止它跑到 Canvas 上方太远)
                if (finalY < canvasRect.top + viewportPadding) {
                    finalY = canvasRect.top + viewportPadding; 
                }
            }


            // 修正 X 轴：使其中心点对准数据点，并防止溢出左/右边界
            finalX = finalX - (tooltipWidth / 2);

            // 如果溢出左侧 (Viewport 左侧 < 0)
            if (finalX < viewportPadding) {
                finalX = viewportPadding; // 强制定位到左侧安全边距
            }
            
            // 如果溢出右侧
            if (finalX + tooltipWidth > viewportWidth - viewportPadding) {
                finalX = viewportWidth - tooltipWidth - viewportPadding; // 强制定位到右侧安全边距
            }
            
            // 5. 设置最终 CSS 位置 (使用绝对位置，即相对于 Body/Viewport)
            tooltipEl.style.left = finalX + 'px';
            tooltipEl.style.top = finalY + 'px';
        }
    };
    // ==========================================================


    let chartInstance = window._chartInstance;
    
    function getCurrentBaseDate() {
        const input = document.getElementById('baseDateInput');
        return input && input.value ? input.value : '';
    }

    function renderChart(data) {
        const ctx = document.getElementById('lineChart').getContext('2d');
        if (window._chartInstance) {
            window._chartInstance.destroy();
        }
        
        const formattedLabels = (data.labels || []).map(formatLabelTimestr);
        const meta = data.lineMeta || [
            {name: '沪深300', code: '000300.XSHG'},
            {name: '科创50', code: '000688.XSHG'},
            {name: 'Deepseek', code: 'Deepseek'}
        ];
        
        const radii1 = getCommentRadii(data.price1, meta[0].code);
        const radii2 = getCommentRadii(data.price2, meta[1].code);
        const radii3 = getCommentRadii(data.price3, meta[2].code); 
        // 检查市值线（Deepseek）是否全为0或全为null/undefined（兼容price3结构）
        let isLine3AllZeroOrNull = false;
        if (Array.isArray(data.price3) && data.price3.length > 0 && data.price3.every(p => p && (p.total_value === 0 || p.total_value === null || p.total_value === undefined))) {
            isLine3AllZeroOrNull = true;
        } else if (Array.isArray(data.line3) && data.line3.length > 0 && data.line3.every(x => x === 0 || x === null || x === undefined)) {
            isLine3AllZeroOrNull = true;
        }

        const baseDate = getCurrentBaseDate(); 
        let baseLineIdx = -1;
        let lineStartIdx = -1; 
        if (baseDate && data.labels && data.labels.length) {
            const firstMatchIndex = data.labels.findIndex(lab => String(lab).slice(0,10) === baseDate);
            if (firstMatchIndex !== -1) {
                baseLineIdx = firstMatchIndex;
                lineStartIdx = firstMatchIndex + 1;
            }
        }
        window._chartBaseIdx = lineStartIdx;
        
        let datasets = [
            { label: meta[0].name, data: data.line1, borderColor: 'rgba(54,162,235,1)', backgroundColor: 'rgba(54,162,235,0.1)', fill: false, pointRadius: radii1, pointHoverRadius: radii1.map(r => r > 0 ? HOVER_POINT_RADIUS : 0), pointBackgroundColor: radii1.map(r => r > 0 ? 'white' : 'rgba(54,162,235,1)'), pointHoverBackgroundColor: radii1.map(r => r > 0 ? 'rgba(54,162,235,1)' : 'rgba(54,162,235,1)'), pointBorderColor: 'rgba(54,162,235,1)', pointBorderWidth: 2, customPrices: data.price1, code: meta[0].code, segment: DYNAMIC_DASH_SEGMENT },
            { label: meta[1].name, data: data.line2, borderColor: 'rgba(75,192,192,1)', backgroundColor: 'rgba(75,192,192,0.1)', fill: false, pointRadius: radii2, pointHoverRadius: radii2.map(r => r > 0 ? HOVER_POINT_RADIUS : 0), pointBackgroundColor: radii2.map(r => r > 0 ? 'white' : 'rgba(75,192,192,1)'), pointHoverBackgroundColor: radii2.map(r => r > 0 ? 'rgba(75,192,192,1)' : 'rgba(75,192,192,1)'), pointBorderColor: 'rgba(75,192,192,1)', pointBorderWidth: 2, customPrices: data.price2, code: meta[1].code, segment: DYNAMIC_DASH_SEGMENT }
        ];
        // 只有市值线不是全0/全空时才加入
        if (!isLine3AllZeroOrNull) {
            datasets.push({ label: meta[2].name, data: data.line3, borderColor: 'rgba(255,99,132,1)', backgroundColor: 'rgba(255,99,132,0.1)', fill: false, pointRadius: radii3, pointHoverRadius: radii3.map(r => r > 0 ? HOVER_POINT_RADIUS : 0), pointBackgroundColor: radii3.map(r => r > 0 ? 'white' : 'rgba(255,99,132,1)'), pointHoverBackgroundColor: radii3.map(r => r > 0 ? 'rgba(255,99,132,1)' : 'rgba(255,99,132,1)'), pointBorderColor: 'rgba(255,99,132,1)', pointBorderWidth: 2, customPrices: data.price3, code: meta[2].code, segment: DYNAMIC_DASH_SEGMENT });
        }

        if (data.customLines && Array.isArray(data.customLines) && data.customPrices && Array.isArray(data.customPrices)) {
            const colors = ['rgba(255,159,64,1)', 'rgba(153,102,255,1)', 'rgba(255,205,86,1)', 'rgba(201,203,207,1)', 'rgba(0,128,128,1)'];
            datasets = datasets.concat(data.customLines.map((line, index) => {
                const customCode = customStocks[index] || `自定义${index + 1}`; 
                const radii = getCommentRadii(data.customPrices[index], customCode);
                const colorIndex = index % colors.length; 
                const borderColor = colors[colorIndex];
                
                return {
                    label: customCode, data: line, borderColor: borderColor, backgroundColor: borderColor.replace('1)', '0.1)'), fill: false, 
                    pointRadius: radii, pointHoverRadius: radii.map(r => r > 0 ? HOVER_POINT_RADIUS : 0), 
                    pointBackgroundColor: radii.map(r => r > 0 ? 'white' : borderColor), pointHoverBackgroundColor: radii.map(r => r > 0 ? borderColor : borderColor), 
                    pointBorderColor: borderColor, pointBorderWidth: 2, customPrices: data.customPrices[index], code: customCode, segment: DYNAMIC_DASH_SEGMENT
                };
            }));
        }

        const chart = new Chart(ctx, {
            type: 'line',
            data: { labels: formattedLabels, datasets: datasets },
            options: {
                responsive: true,
                interaction: { mode: 'nearest', intersect: true },
                hover: { mode: 'nearest', intersect: true, animationDuration: 0 },
                plugins: {
                    legend: { position: 'top', labels: { font: { size: 16 } } },
                    tooltip: {
                        enabled: false, 
                        external: externalTooltipHandler,
                        mode: 'nearest',
                        intersect: true,
                    },
                    annotation: {
                        annotations: baseLineIdx >= 0 ? {
                                baseLine: {
                                    type: 'line', xMin: baseLineIdx, xMax: baseLineIdx, borderColor: 'rgba(255, 140, 0, 0.3)', borderWidth: 4, borderDash: [6, 6],
                                    label: { display: true, content: '基准', position: 'start', backgroundColor: 'rgba(255, 140, 0, 0.85)', color: 'white', font: { weight: 'bold' } }
                                }
                        } : {} 
                    }
                },
                scales: { x: { display: true }, y: { beginAtZero: false } } 
            }
        });

        window._chartInstance = chart;
    }
    
    // [其余的股票管理和初始化逻辑保持不变]
    function renderCustomStockList() {
        const listDiv = document.getElementById('customStockList');
        listDiv.innerHTML = '';
        customStocks.forEach((code, idx) => {
            const span = document.createElement('span');
            span.textContent = code;
            span.style.cssText = 'display:inline-block;background:#f2f2f2;border-radius:3px;padding:1px 6px;margin:0 4px 2px 0;';
            const delBtn = document.createElement('button');
            delBtn.textContent = '×';
            delBtn.title = '删除';
            delBtn.style.cssText = 'margin-left:2px;font-size:12px;color:#c00;background:none;border:none;cursor:pointer;';
            delBtn.onclick = function() {
                customStocks.splice(idx,1);
                renderCustomStockList();
                triggerChartUpdate();
                if (window.saveCustomCodes) window.saveCustomCodes(customStocks); 
            };
            span.appendChild(delBtn);
            listDiv.appendChild(span);
        });
    }
    document.getElementById('addCustomStockBtn').onclick = function() {
        const input = document.getElementById('customStockInput');
        let code = input.value.trim();
        if (!code) return;
        if (customStocks.length >= 5) { alert('最多添加5个自定义股票'); return; }
        
        let codeNorm = code;
        if (!/\.X[SA]HG$|\.KH$|\.XSHE$/i.test(code)) {
            if (/^\d{6}$/.test(code)) {
                if (code.startsWith('60')) codeNorm = code + '.XSHG';
                else if (code.startsWith('00') || code.startsWith('30')) codeNorm = code + '.XSHE';
            }
        }
        
        if (customStocks.includes(codeNorm)) { alert('已存在'); return; }
        customStocks.push(codeNorm);
        input.value = '';
        renderCustomStockList();
        triggerChartUpdate();
        if (window.saveCustomCodes) window.saveCustomCodes(customStocks); 
    };
    function triggerChartUpdate() {
        const val = document.getElementById('baseDateInput').value;
        fetchData(val, customStocks).then(renderChart);
    }
    
    document.getElementById('baseDateBtn').onclick = function() {
        triggerChartUpdate();
    };

    function initializeChart() {
        if (window.loadCustomCodes) {
            customStocks = window.loadCustomCodes() || [];
        }
        renderCustomStockList();
    }

    initializeChart();
</script>
</body>
</html>